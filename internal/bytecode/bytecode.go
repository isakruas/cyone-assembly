package bytecode

import (
	"fmt"
	"strconv"

	pkg_ast "cyone/internal/ast"
	pkg_token "cyone/internal/token"
)

type Bytecode struct {
	Address  uint16
	Opcode   byte
	Operands []byte
}

type Interval struct {
	Start uint16
	End   uint16
}

type IntervalManager struct {
	intervals []Interval
}

func NewIntervalManager() *IntervalManager {
	return &IntervalManager{
		intervals: []Interval{},
	}
}

// AddInterval adds a new interval to the manager, ensuring no overlaps with existing intervals.
// Returns an error if the interval is invalid or overlaps with an existing interval.
func (im *IntervalManager) AddInterval(start, end uint16) error {
	if start > end {
		return fmt.Errorf("invalid interval: start (0x%04X) is greater than end (0x%04X)", start, end)
	}

	for _, interval := range im.intervals {
		// Check for overlap
		if !(end < interval.Start || start > interval.End) {
			return fmt.Errorf("interval overlap detected between (0x%04X - 0x%04X) and (0x%04X - 0x%04X)", start, end, interval.Start, interval.End)
		}
	}

	im.intervals = append(im.intervals, Interval{Start: start, End: end})
	return nil
}

// PrintIntervals prints all intervals managed by the IntervalManager.
func (im *IntervalManager) PrintIntervals() {
	for _, interval := range im.intervals {
		fmt.Printf("interval: 0x%04X - 0x%04X\n", interval.Start, interval.End)
	}
}

// generateExpressionOperands generates the bytecode operands for a given expression.
// It handles different types of expressions (variables, constants, binary expressions, memory locations, and byte values).
// Returns the generated bytecode operands and an error if any issue occurs.
func generateExpressionOperands(expr pkg_ast.Expression, variableAddressMap map[string]uint16) ([]byte, error) {
	var operands []byte
	switch expr := expr.(type) {
	case *pkg_ast.Variable:
		address, exists := variableAddressMap[expr.Name]
		if !exists {
			return nil, fmt.Errorf("variable '%s' not found in the variable address map", expr.Name)
		}
		operands = append(operands, 0x00, byte((address>>8)&0xFF), byte(address&0xFF))
	case *pkg_ast.Constant:
		operands = append(operands, 0x01)
		value, err := strconv.ParseInt(expr.Value, 0, 8)
		if err != nil {
			return nil, fmt.Errorf("failed to convert constant '%s' to integer: %v", expr.Value, err)
		}
		operands = append(operands, uint8(value))
	case *pkg_ast.BinaryExpression:
		operands = append(operands, 0x02)
		var token pkg_token.TokenType
		if len(expr.Operator) == 1 {
			var exists bool
			token, exists = pkg_token.SingleCharTokens[expr.Operator[0]]
			if !exists {
				return nil, fmt.Errorf("single character token '%s' not found in the token map", expr.Operator)
			}
		} else if len(expr.Operator) == 2 {
			var exists bool
			token, exists = pkg_token.MultiCharTokens[expr.Operator]
			if !exists {
				return nil, fmt.Errorf("multi-character token '%s' not found in the token map", expr.Operator)
			}
		}
		tokenOpcode, exists := pkg_token.TokenOpcodes[token]
		if !exists {
			return nil, fmt.Errorf("token opcode for '%s' not found in the token opcodes map", expr.Operator)
		}
		operands = append(operands, tokenOpcode)
		leftOperands, err := generateExpressionOperands(expr.LeftExpression, variableAddressMap)
		if err != nil {
			return nil, err
		}
		operands = append(operands, leftOperands...)
		rightOperands, err := generateExpressionOperands(expr.RightExpression, variableAddressMap)
		if err != nil {
			return nil, err
		}
		operands = append(operands, rightOperands...)

	case *pkg_ast.MemoryLocation:
		address, exists := variableAddressMap[expr.Address]
		if !exists {
			tempValue, err := strconv.ParseInt(expr.Address, 0, 16)
			if err != nil {
				return nil, fmt.Errorf("failed to convert memory location address '%s' to integer: %v", expr.Address, err)
			}
			address = uint16(tempValue)
		}
		operands = append(operands, 0x00, byte((address>>8)&0xFF), byte(address&0xFF))

	case *pkg_ast.ByteValue:
		operands = append(operands, 0x01)
		value, err := strconv.ParseInt(expr.Value, 0, 8)
		if err != nil {
			return nil, fmt.Errorf("failed to convert byte value '%s' to integer: %v", expr.Value, err)
		}
		operands = append(operands, uint8(value))
	default:
		return nil, fmt.Errorf("unexpected expression type: %T", expr)
	}
	return operands, nil
}

// generateStatementOperands generates the bytecode operands for a given statement.
// It handles different types of statements (assignments, if statements, goto statements, and function calls).
// Returns the generated bytecode operands and an error if any issue occurs.
func generateStatementOperands(stmt pkg_ast.Statement, variableAddressMap map[string]uint16) ([]byte, error) {
	var operands []byte
	switch s := stmt.(type) {
	case *pkg_ast.Assignment:
		address, exists := variableAddressMap[s.VariableName]
		if !exists {
			return nil, fmt.Errorf("variable '%s' not found in the variable address map", s.VariableName)
		}
		u := []byte{
			pkg_token.OP_IDENTIFIER,
			byte((address >> 8) & 0xFF),
			byte(address & 0xFF),
			pkg_token.OP_ASSIGN,
		}
		exprOperands, err := generateExpressionOperands(s.Expression, variableAddressMap)
		if err != nil {
			return nil, err
		}
		u = append(u, exprOperands...)
		u = append(u, pkg_token.OP_EOF)
		operands = append(operands, u...)
	case *pkg_ast.IfStatement:
		u := []byte{
			pkg_token.OP_IF,
		}
		u = append(u, pkg_token.OP_LPAREN)
		conditionOperands, err := generateExpressionOperands(s.ConditionExpression, variableAddressMap)
		if err != nil {
			return nil, err
		}
		u = append(u, conditionOperands...)
		u = append(u, pkg_token.OP_RPAREN)
		u = append(u, 0x00, pkg_token.OP_LBRACE)
		if s.ThenBlock != nil {
			for _, stmt := range s.ThenBlock.Statements {
				thenOperands, err := generateStatementOperands(stmt, variableAddressMap)
				if err != nil {
					return nil, err
				}
				u = append(u, thenOperands...)
			}
		}
		u = append(u, pkg_token.OP_RBRACE)
		u = append(u, 0x01, pkg_token.OP_LBRACE)
		if s.ElseBlock != nil {
			for _, stmt := range s.ThenBlock.Statements {
				elseOperands, err := generateStatementOperands(stmt, variableAddressMap)
				if err != nil {
					return nil, err
				}
				u = append(u, elseOperands...)
			}
		}
		u = append(u, pkg_token.OP_RBRACE)
		operands = append(operands, u...)
	case *pkg_ast.Goto:
		address, err := strconv.ParseInt(s.Address, 0, 16)
		if err != nil {
			return nil, fmt.Errorf("failed to convert goto address '%s' to integer: %v", s.Address, err)
		}
		u := []byte{
			pkg_token.OP_GOTO,
			byte((address >> 8) & 0xFF),
			byte(address & 0xFF),
			pkg_token.OP_EOF,
		}
		operands = append(operands, u...)
	case *pkg_ast.Call:
		u := []byte{
			pkg_token.OP_CALL,
		}
		functionToken, exists := pkg_token.FunctionOpCodes[s.FunctionName]
		if !exists {
			return nil, fmt.Errorf("function '%s' not found in the function opcodes map", s.FunctionName)
		}
		u = append(u, functionToken, pkg_token.OP_LPAREN)
		for _, expr := range s.Parameters {
			paramOperands, err := generateExpressionOperands(expr, variableAddressMap)
			if err != nil {
				return nil, err
			}
			u = append(u, paramOperands...)
		}
		u = append(u, pkg_token.OP_RPAREN, pkg_token.OP_EOF)
		operands = append(operands, u...)
	case *pkg_ast.MemoryAssignment:
		address, err := strconv.ParseInt(s.MemoryAddress.(*pkg_ast.Constant).Value, 0, 16)
		if err != nil {
			return nil, fmt.Errorf("failed to convert memory address '%s' to integer: %v", s.MemoryAddress.(*pkg_ast.Constant).Value, err)
		}
		u := []byte{
			pkg_token.OP_IDENTIFIER,
			byte((address >> 8) & 0xFF),
			byte(address & 0xFF),
			pkg_token.OP_ASSIGN,
		}
		exprOperands, err := generateExpressionOperands(s.Value, variableAddressMap)
		if err != nil {
			return nil, err
		}
		u = append(u, exprOperands...)
		u = append(u, pkg_token.OP_EOF)
		operands = append(operands, u...)
	default:
		return nil, fmt.Errorf("unexpected statement type: %T", s)
	}
	return operands, nil
}

// GenerateBytecode generates bytecode from a given program. It starts with a start address and processes each block in the program.
// Returns a slice of Bytecode objects representing the bytecode for the program and an error if any issue occurs.
func GenerateBytecode(program *pkg_ast.Program) ([]Bytecode, error) {
	var bytecodeList []Bytecode

	if program.Start != nil {
		startAddress, err := strconv.ParseInt(program.Start.Address, 0, 16)
		if err != nil {
			return nil, fmt.Errorf("failed to convert start address '%s' to integer: %v", program.Start.Address, err)
		}
		startBytecode := Bytecode{
			Address:  0x0000,
			Opcode:   pkg_token.OP_START,
			Operands: []byte{byte((startAddress >> 8) & 0xFF), byte(startAddress & 0xFF), pkg_token.OP_EOF},
		}
		bytecodeList = append(bytecodeList, startBytecode)
	}
	variableAddressMap := make(map[string]uint16, len(program.Variables))
	for _, varDecl := range program.Variables {
		address, err := strconv.ParseInt(varDecl.Address, 0, 16)
		if err != nil {
			return nil, fmt.Errorf("failed to convert variable address '%s' to integer: %v", varDecl.Address, err)
		}
		variableAddressMap[varDecl.Name] = uint16(address)
	}
	intervalManager := NewIntervalManager()
	for _, block := range program.Blocks {
		blockOperands := []byte{pkg_token.OP_LBRACE}
		for _, stmt := range block.Statements {
			stmtOperands, err := generateStatementOperands(stmt, variableAddressMap)
			if err != nil {
				return nil, err
			}
			blockOperands = append(blockOperands, stmtOperands...)
		}
		blockOperands = append(blockOperands, pkg_token.OP_RBRACE)
		blockAddress, err := strconv.ParseInt(block.Address, 0, 16)
		if err != nil {
			return nil, fmt.Errorf("failed to convert block address '%s' to integer: %v", block.Address, err)
		}
		nOperands := int16(len(blockOperands))
		blockOperands = append([]byte{byte((nOperands >> 8) & 0xFF), byte(nOperands & 0xFF)}, blockOperands...)
		blockBytecode := Bytecode{
			Address:  uint16(blockAddress),
			Opcode:   pkg_token.OP_BLOCK,
			Operands: blockOperands,
		}
		blockAddressEnd := uint16(blockAddress) + uint16(len(blockBytecode.Operands))
		if err := intervalManager.AddInterval(uint16(blockAddress), blockAddressEnd); err != nil {
			return nil, err
		}
		bytecodeList = append(bytecodeList, blockBytecode)
	}

	// intervalManager.PrintIntervals()

	return bytecodeList, nil
}

//////////////////////////////////////////////////////

// Function to convert a byte to a hexadecimal string
func toHexByte(b byte) string {
	return fmt.Sprintf("%02X", b)
}

// Function to convert a uint16 to a hexadecimal string
func toHexWord(w uint16) string {
	return fmt.Sprintf("%04X", w)
}

// Function to calculate checksum
func calculateChecksum(record string) byte {
	sum := 0
	for i := 1; i < len(record); i += 2 {
		var value byte
		fmt.Sscanf(record[i:i+2], "%02X", &value)
		sum += int(value)
	}
	return byte(((^sum) + 1) & 0xFF)
}

// Function to generate an Intel HEX record line
func generateRecord(address uint16, data []byte) string {
	length := byte(len(data))
	record := fmt.Sprintf(":%02X%s00", length, toHexWord(address))
	for _, b := range data {
		record += toHexByte(b)
	}
	checksum := calculateChecksum(record)
	return record + toHexByte(checksum)
}

// Function to generate the Intel HEX file from the provided bytecodes
func GenerateIntelHex(bytecodes []Bytecode) []string {
	var lines []string

	for _, bc := range bytecodes {
		// Create byte slice for the Opcode and Operands
		data := append([]byte{bc.Opcode}, bc.Operands...)

		// Create HEX records for each data segment (maximum 16 bytes per line)
		for i := 0; i < len(data); i += 16 {
			end := i + 16
			if end > len(data) {
				end = len(data)
			}
			segment := data[i:end] // Segment data for the current record
			line := generateRecord(bc.Address+uint16(i), segment)
			lines = append(lines, line)
		}
	}

	lines = append(lines, ":00000001FF") // Add end-of-file record
	return lines
}
